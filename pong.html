<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pong-Ultra Game</title>
  <style>
    #gameContainer {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    canvas { 
      background: linear-gradient(to bottom, #1e3c72, #2a5298); /* æ¸å˜èƒŒæ™¯ */
      display: block; 
      margin: auto; 
      border: 5px solid white; /* æ·»åŠ è¾¹æ¡† */
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.5); /* æ·»åŠ å…‰æ™•æ•ˆæœ */
    }
    body { 
      margin: 0; 
      overflow: hidden; 
      font-family: Arial, sans-serif; 
      background: #000; /* èƒŒæ™¯é¢œè‰² */
      color: white; 
      text-align: center; 
    }
    #controls {
      position: relative;
      margin-bottom: 10px;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      margin: 0 10px;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      background: #000005;
      color: white;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      transition: background 0.3s, transform 0.2s;
    }
    button:hover {
      background: #63b8ff;
      transform: scale(1.1);
    }
    button:active {
      background: #4682b4;
    }
    #scoreboard {
      position: relative;
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 20px;
    }
    /* è¿å‡»è®¡æ•°å™¨æ ·å¼ */
    #comboCounter {
      font-size: 24px;
      font-weight: bold;
      color: white;
      text-align: center;
      margin-top: 10px;
    }
    /* æ‰«æçº¿æ•ˆæœ */
    #scanlines {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none; /* ç¡®ä¿æ‰«æçº¿ä¸ä¼šå½±å“ç”¨æˆ·äº¤äº’ */
      background: repeating-linear-gradient(
        to bottom,
        rgba(255, 255, 255, 0.05),
        rgba(255, 255, 255, 0.05) 2px,
        transparent 2px,
        transparent 8px
      );
      animation: scanlineMove 2s linear infinite; /* æ‰«æçº¿ç§»åŠ¨åŠ¨ç”» */
    }

    /* æ‰«æçº¿ç§»åŠ¨åŠ¨ç”» */
    @keyframes scanlineMove {
      0% {
        transform: translateY(0);
      }
      100% {
        transform: translateY(4px);
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <div id="controls">
      <button id="startPauseBtn">Pause</button> <!-- æš‚åœæŒ‰é’® -->
      <button id="resetBtn">Reset</button> <!-- é‡ç½®æŒ‰é’® -->
      <button id="backToTitleBtn">Back to Title</button> <!-- å›åˆ°æ ‡é¢˜é¡µé¢æŒ‰é’® -->
    </div>
    <div id="scoreboard">
      Player 1: <span id="playerScore">0</span> | Player 2: <span id="aiScore">0</span>
    </div>
    <canvas id="pong" width="1280" height="720"></canvas>
    <!-- åœ¨æ¸¸æˆç”»å¸ƒä¸‹æ–¹æ·»åŠ è¿å‡»è®¡æ•°å™¨ -->
    <div id="comboCounter">Combo 0</div>
  </div>
  <div id="scanlines"></div>
  <script>
    const canvas = document.getElementById('pong');
    const ctx = canvas.getContext('2d');
    const startPauseBtn = document.getElementById('startPauseBtn');
    const resetBtn = document.getElementById('resetBtn');
    const backToTitleBtn = document.getElementById('backToTitleBtn');
    const playerScoreEl = document.getElementById('playerScore');
    const aiScoreEl = document.getElementById('aiScore');
    const gameContainer = document.getElementById('gameContainer');

    const paddleWidth = 20, paddleHeight = 100, ballSize = 15;
    const player1 = { x: 10, y: canvas.height / 2 - paddleHeight / 2, dy: 0, score: 0 };
    const player2 = { x: canvas.width - 30, y: canvas.height / 2 - paddleHeight / 2, dy: 0, score: 0 };

    let isPaused = false; // æ¸¸æˆé»˜è®¤å¼€å§‹
    const gameMode = localStorage.getItem('gameMode') || 'ai'; // ä» localStorage è·å–æ¨¡å¼
    const isPvP = gameMode === 'pvp'; // æ ¹æ®æ¨¡å¼è®¾ç½®æ˜¯å¦ä¸ºåŒäººå¯¹æˆ˜

    const hitSound = new Audio('lib/hit.wav'); // ç¢°æ’éŸ³æ•ˆ
    const scoreSound = new Audio('lib/score.wav'); // å¾—åˆ†éŸ³æ•ˆ
    const bgMusic = new Audio('lib/background.mp3'); // èƒŒæ™¯éŸ³ä¹
    bgMusic.loop = true;
    bgMusic.play(); // è‡ªåŠ¨æ’­æ”¾èƒŒæ™¯éŸ³ä¹

    // åˆå§‹åŒ–å°çƒé€Ÿåº¦
    const initialSpeed = 4; // åˆå§‹é€Ÿåº¦
    let ballSpeed = initialSpeed; // å½“å‰é€Ÿåº¦

    // åˆå§‹åŒ–å°çƒ
    let ball = { x: canvas.width / 2, y: canvas.height / 2, dx: 4, dy: 4, isWaiting: false };

    // åˆå§‹åŒ–ç –å—æ•°ç»„
    let bricks = [];

    // åˆå§‹åŒ–è¿å‡»è®¡æ•°å™¨
    let comboCount = 0;
    const comboCounterEl = document.getElementById('comboCounter');

    // åˆå§‹åŒ–ç²’å­æ•°ç»„
    let particles = [];

    // æ›´æ–°è¿å‡»è®¡æ•°å™¨
    function updateComboCounter() {
        comboCounterEl.textContent = `Combo ${comboCount}`;
        const baseFontSize = 24; // åŸºç¡€å­—ä½“å¤§å°
        const maxFontSize = 72; // æœ€å¤§å­—ä½“å¤§å°
        const newFontSize = Math.min(baseFontSize + comboCount * 2, maxFontSize); // æ ¹æ®è¿å‡»æ¬¡æ•°åŠ¨æ€è°ƒæ•´å­—ä½“å¤§å°
        comboCounterEl.style.fontSize = `${newFontSize}px`;
    }

    // åœ¨å°çƒä¸ç –å—æˆ–æŒ¡æ¿ç¢°æ’æ—¶å¢åŠ è¿å‡»è®¡æ•°
    function incrementCombo() {
        comboCount++;
        updateComboCounter();
    }

    // åœ¨å°çƒå‡ºç•Œæ—¶é‡ç½®è¿å‡»è®¡æ•°
    function resetCombo() {
        comboCount = 0;
        updateComboCounter();
    }

    // ç”Ÿæˆéšæœºç –å—
    function generateBrick() {
        const brickWidth = 100;
        const brickHeight = 20;
        const brickX = Math.random() * (canvas.width - brickWidth); // éšæœºæ°´å¹³ä½ç½®
        const brickY = Math.random() * (canvas.height); // éšæœºå‚ç›´ä½ç½®

        // éšæœºç¡®å®šç –å—é¢œè‰²
        let color = 'Silver'; // é»˜è®¤é¢œè‰²ä¸ºé“¶è‰²
        const randomChance = Math.random();
        if (randomChance < 0.1) {
            color = 'PaleTurquoise'; // 10%å‡ ç‡ç”Ÿæˆæµ…ç»¿æ¾çŸ³ç –å—
        } else if (randomChance < 0.2) {
            color = 'PaleVioletRed'; // 10%å‡ ç‡ç”Ÿæˆæµ…ç´«ç½—å…°çº¢ç –å—
        } else if (randomChance < 0.4) {
            color = 'MediumSeaGreen'; // 20%å‡ ç‡ç”Ÿæˆä¸­æµ·ç»¿è‰²ç –å—
        }

        bricks.push({ x: brickX, y: brickY, width: brickWidth, height: brickHeight, color });
    }

    // ç»˜åˆ¶ç –å—
    function drawBricks() {
        bricks.forEach(brick => {
            drawRect(brick.x, brick.y, brick.width, brick.height, brick.color); // æ ¹æ®ç –å—çš„é¢œè‰²ç»˜åˆ¶
        });
    }

    // æ£€æµ‹å°çƒä¸ç –å—çš„ç¢°æ’
    function checkBrickCollision() {
        bricks = bricks.filter(brick => {
            if (
                ball.x + ballSize > brick.x &&
                ball.x - ballSize < brick.x + brick.width &&
                ball.y + ballSize > brick.y &&
                ball.y - ballSize < brick.y + brick.height
            ) {
                incrementCombo(); // å¢åŠ è¿å‡»è®¡æ•°

                // æ ¹æ®ç –å—é¢œè‰²è§¦å‘ä¸åŒæ•ˆæœ
                if (brick.color === 'PaleTurquoise') {
                    ballSpeed = Math.max(ballSpeed - 2, 2); // å¤§å¹…é™ä½é€Ÿåº¦ï¼Œæœ€ä½ä¸º2
                } else if (brick.color === 'PaleVioletRed') {
                    ballSpeed += 2; // å¤§å¹…æé«˜é€Ÿåº¦
                } else if (brick.color === 'MediumSeaGreen') {
                    // ä½¿å°çƒä»¥å®Œå…¨éšæœºçš„è§’åº¦åå¼¹ï¼Œä¸”ä¸ y è½´è‡³å°‘å‘ˆç° 30Â°è§’
                    let randomAngle;
                    do {
                        randomAngle = Math.random() * Math.PI * 2; // éšæœºè§’åº¦ï¼ˆ0 åˆ° 360Â°ï¼‰
                    } while (Math.abs(Math.sin(randomAngle)) < Math.sin(Math.PI / 6)); // ç¡®ä¿ä¸ y è½´è‡³å°‘å‘ˆç° 30Â°è§’

                    ball.dx = ballSpeed * Math.cos(randomAngle);
                    ball.dy = ballSpeed * Math.sin(randomAngle);
                }

                // è®¡ç®—å…¥å°„è§’å¹¶åå°„ï¼ˆé MediumSeaGreen ç –å—ï¼‰
                if (brick.color !== 'MediumSeaGreen') {
                    if (ball.y < brick.y || ball.y > brick.y + brick.height) {
                        ball.dy *= -1; // å‚ç›´åå°„
                    } else {
                        ball.dx *= -1; // æ°´å¹³åå°„
                    }
                }

                hitSound.play(); // æ’­æ”¾ç¢°æ’éŸ³æ•ˆ
                return false; // ç§»é™¤è¢«ç¢°æ’çš„ç –å—
            }
            return true; // ä¿ç•™æœªç¢°æ’çš„ç –å—
        });
    }

    // ç”Ÿæˆç²’å­æ•ˆæœ
    function generateBallParticles(x, y) {
        const particleCount = Math.min(Math.floor(ballSpeed * 2), 20); // æ ¹æ®é€Ÿåº¦åŠ¨æ€è°ƒæ•´ç²’å­æ•°é‡ï¼Œæœ€å¤§ä¸º 20
        const particleColor = ballSpeed < 4.5 ? 'DeepSkyBlue' : ballSpeed > 5.5 ? 'Crimson' : 'white'; // æ ¹æ®å°çƒé¢œè‰²è®¾ç½®ç²’å­é¢œè‰²

        for (let i = 0; i < particleCount; i++) {
            particles.push({
                x: x,
                y: y,
                dx: (Math.random() - 0.5) * 2, // éšæœºæ°´å¹³é€Ÿåº¦
                dy: (Math.random() - 0.5) * 2, // éšæœºå‚ç›´é€Ÿåº¦
                size: Math.random() * 3 + 1, // éšæœºç²’å­å¤§å°
                color: particleColor, // ç²’å­é¢œè‰²è·Ÿéšå°çƒé¢œè‰²
                life: 30 // ç²’å­å¯¿å‘½
            });
        }
    }

    // ç»˜åˆ¶ç²’å­æ•ˆæœ
    function drawParticles() {
        particles.forEach((particle, index) => {
            ctx.fillStyle = particle.color;
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            ctx.fill();

            // æ›´æ–°ç²’å­ä½ç½®
            particle.x += particle.dx;
            particle.y += particle.dy;
            particle.life--;

            // ç§»é™¤å¯¿å‘½è€—å°½çš„ç²’å­
            if (particle.life <= 0) {
                particles.splice(index, 1);
            }
        });
    }

    function drawRect(x, y, w, h, color = 'white') {
        ctx.fillStyle = color;
        ctx.fillRect(x, y, w, h);
    }

    function drawCircle(x, y, r) {
        // æ ¹æ®å°çƒé€Ÿåº¦è®¾ç½®é¢œè‰²
        let color;
        if (ballSpeed < 4.5) {
            color = 'DeepSkyBlue'; // æ·±å¤©è“
        } else if (ballSpeed > 5.5) {
            color = 'Crimson'; // ç»¯çº¢
        } else {
            color = 'white'; // ç™½è‰²
        }

        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
    }

    function shakeScreen() {
        const intensity = 5; // æ™ƒåŠ¨å¼ºåº¦
        let count = 0;
        const interval = setInterval(() => {
            const offsetX = (Math.random() * intensity * 2 - intensity).toFixed(2);
            const offsetY = (Math.random() * intensity * 2 - intensity).toFixed(2);
            gameContainer.style.transform = `translate(-50%, -50%) translate(${offsetX}px, ${offsetY}px)`; // ä¿æŒå±…ä¸­å¹¶æ·»åŠ æ™ƒåŠ¨
            count++;
            if (count > 10) {
                clearInterval(interval);
                gameContainer.style.transform = 'translate(-50%, -50%)'; // æ¢å¤å±…ä¸­
            }
        }, 50);
    }

    function resetBall() {
        ball.isWaiting = true; // è®¾ç½®å°çƒä¸ºç­‰å¾…çŠ¶æ€
        ball.x = canvas.width / 2; // æ°´å¹³ä½ç½®å›ºå®šåœ¨ä¸­è½´çº¿ä¸Š
        ball.y = Math.random() * (canvas.height - 2 * ballSize) + ballSize; // å‚ç›´æ–¹å‘éšæœºä½ç½®

        // éšæœºæ–¹å‘
        const angle = Math.random() * Math.PI / 2 - Math.PI / 4; // éšæœºè§’åº¦ï¼ˆ-45Â°åˆ°45Â°ï¼‰
        ballSpeed = initialSpeed; // é‡ç½®é€Ÿåº¦
        ball.dx = (Math.random() > 0.5 ? 1 : -1) * ballSpeed * Math.cos(angle);
        ball.dy = ballSpeed * Math.sin(angle);

        // å»¶è¿Ÿ 1 ç§’åå¼€å§‹ç§»åŠ¨
        setTimeout(() => {
            ball.isWaiting = false;
        }, 1000);
    }

    function updateScore() {
        playerScoreEl.textContent = player1.score;
        aiScoreEl.textContent = player2.score;
    }

    function update() {
        if (isPaused) return;

        // å°çƒç§»åŠ¨æ—¶ç”Ÿæˆç²’å­æ•ˆæœ
        if (!ball.isWaiting) {
            generateBallParticles(ball.x, ball.y);
        }

        // Move player 1 paddle
        player1.y += player1.dy;
        player1.y = Math.max(0, Math.min(canvas.height - paddleHeight, player1.y));

        // Move player 2 paddle (AI or player-controlled)
        if (isPvP) {
            player2.y += player2.dy;
            player2.y = Math.max(0, Math.min(canvas.height - paddleHeight, player2.y));
        } else {
            player2.y += ball.y > player2.y + paddleHeight / 2 ? 4 : -4;
            player2.y = Math.max(0, Math.min(canvas.height - paddleHeight, player2.y));
        }

        // å¦‚æœå°çƒå¤„äºç­‰å¾…çŠ¶æ€ï¼Œåˆ™ä¸æ›´æ–°å…¶ä½ç½®
        if (ball.isWaiting) return;

        // Move ball
        ball.x += ball.dx;
        ball.y += ball.dy;

        // Ball collision with top/bottom walls
        if (ball.y <= 0 || ball.y >= canvas.height) {
            ball.dy *= -1;
            hitSound.play();
            shakeScreen(); // å¢åŠ æ™ƒåŠ¨æ•ˆæœ
        }

        // Ball collision with paddles
        if (
            (ball.x <= player1.x + paddleWidth && ball.y >= player1.y && ball.y <= player1.y + paddleHeight) ||
            (ball.x >= player2.x - ballSize && ball.y >= player2.y && ball.y <= player2.y + paddleHeight)
        ) {
            incrementCombo(); // å¢åŠ è¿å‡»è®¡æ•°
            // è®¡ç®—å…¥å°„è§’å¹¶åå°„
            const paddle = ball.x <= canvas.width / 2 ? player1 : player2;
            const relativeIntersectY = ball.y - (paddle.y + paddleHeight / 2);
            const normalizedRelativeIntersectY = relativeIntersectY / (paddleHeight / 2);
            const bounceAngle = normalizedRelativeIntersectY * (Math.PI / 4); // æœ€å¤§åå°„è§’ä¸º 45Â°

            ball.dx = ball.dx > 0 ? -Math.abs(ballSpeed * Math.cos(bounceAngle)) : Math.abs(ballSpeed * Math.cos(bounceAngle));
            ball.dy = ballSpeed * Math.sin(bounceAngle);

            ballSpeed += 0.5; // æ¯æ¬¡ç¢°æ’åé€Ÿåº¦å¢åŠ 
            hitSound.play(); // æ’­æ”¾ç¢°æ’éŸ³æ•ˆ
            shakeScreen(); // å¢åŠ æ™ƒåŠ¨æ•ˆæœ

            // æ¯æ¬¡æŒ¡æ¿ç¢°æ’åç”Ÿæˆæ–°çš„ç –å—
            generateBrick();
        }

        // æ£€æµ‹å°çƒä¸ç –å—çš„ç¢°æ’
        checkBrickCollision();

        // Reset ball if out of bounds and update score
        if (ball.x <= 0) {
            player2.score++;
            updateScore();
            resetBall();
            resetCombo(); // é‡ç½®è¿å‡»è®¡æ•°
            scoreSound.play();
        } else if (ball.x >= canvas.width) {
            player1.score++;
            updateScore();
            resetBall();
            resetCombo(); // é‡ç½®è¿å‡»è®¡æ•°
            scoreSound.play();
        }
    }

    function render() {
        drawRect(0, 0, canvas.width, canvas.height, 'black'); // æ¸…å±
        drawParticles(); // ç»˜åˆ¶ç²’å­æ•ˆæœ
        drawRect(player1.x, player1.y, paddleWidth, paddleHeight); // Player 1 paddle
        drawRect(player2.x, player2.y, paddleWidth, paddleHeight); // Player 2 paddle
        drawCircle(ball.x, ball.y, ballSize); // Ball
        drawBricks(); // ç»˜åˆ¶ç –å—
    }

    function gameLoop() {
        update();
        render();
        requestAnimationFrame(gameLoop);
    }

    // æš‚åœæŒ‰é’®åŠŸèƒ½
    startPauseBtn.addEventListener('click', () => {
        isPaused = !isPaused;
        if (!isPaused) {
            bgMusic.play();
            startPauseBtn.textContent = 'Pause';
        } else {
            bgMusic.pause();
            startPauseBtn.textContent = 'Start';
        }
    });

    // é‡ç½®æŒ‰é’®åŠŸèƒ½
    resetBtn.addEventListener('click', () => {
        player1.score = 0;
        player2.score = 0;
        player1.y = canvas.height / 2 - paddleHeight / 2;
        player2.y = canvas.height / 2 - paddleHeight / 2;
        bricks = []; // æ¸…ç©ºç –å—æ•°ç»„
        resetBall();
        resetCombo(); // é‡ç½®è¿å‡»è®¡æ•°
        updateScore();
    });

    // å›åˆ°æ ‡é¢˜é¡µé¢æŒ‰é’®åŠŸèƒ½
    backToTitleBtn.addEventListener('click', () => {
        bgMusic.pause(); // åœæ­¢èƒŒæ™¯éŸ³ä¹
        window.location.href = 'title.html'; // è·³è½¬åˆ°æ ‡é¢˜é¡µé¢
    });

    // é”®ç›˜æ§åˆ¶
    document.addEventListener('keydown', e => {
        if (e.key === 'w' || e.key === 'W') player1.dy = -6;
        if (e.key === 's' || e.key === 'S') player1.dy = 6;

        if (isPvP) {
            if (e.key === 'ArrowUp') player2.dy = -6;
            if (e.key === 'ArrowDown') player2.dy = 6;
        }
    });

    document.addEventListener('keyup', e => {
        if (e.key === 'w' || e.key === 'W' || e.key === 's' || e.key === 'S') player1.dy = 0;
        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') player2.dy = 0;
    });

    resetBall(); // åˆå§‹åŒ–å°çƒ
    generateBrick(); // åˆå§‹åŒ–æ—¶ç”Ÿæˆä¸€ä¸ªç –å—
    gameLoop(); // å¼€å§‹æ¸¸æˆå¾ªç¯
  </script>
  <script>
    // åˆ›å»ºé™éŸ³æŒ‰é’®
    const muteBtn = document.createElement('button');
    muteBtn.id = 'muteBtn';
    muteBtn.textContent = 'ğŸ”Š'; // é»˜è®¤æ˜¾ç¤ºä¸ºéŸ³é‡å›¾æ ‡
    muteBtn.style.position = 'absolute';
    muteBtn.style.top = '10px'; // ç›¸å¯¹äº #gameContainer çš„é¡¶éƒ¨
    muteBtn.style.left = '10px'; // ç›¸å¯¹äº #gameContainer çš„å·¦ä¾§
    muteBtn.style.width = '50px';
    muteBtn.style.height = '50px';
    muteBtn.style.border = '5px solid white'; // è®¾ç½®ä¸ #gameContainer ä¸€è‡´çš„ç™½è‰²è¾¹æ¡†
    muteBtn.style.borderRadius = '10px'; // åœ†è§’æ–¹å½¢
    muteBtn.style.background = '#000000'; // è®¾ç½®èƒŒæ™¯é¢œè‰²ä¸ºé»‘è‰²
    muteBtn.style.color = 'white'; // ä¿æŒæ–‡å­—é¢œè‰²ä¸ºç™½è‰²
    muteBtn.style.fontSize = '20px';
    muteBtn.style.cursor = 'pointer';
    muteBtn.style.boxShadow = '0 0 20px rgba(255, 255, 255, 0.5)'; // è®¾ç½®ä¸ #gameContainer ä¸€è‡´çš„å‘å…‰æ•ˆæœ
    muteBtn.style.zIndex = '10'; // ç¡®ä¿æŒ‰é’®ä½äºå†…å®¹ä¸Šæ–¹

    // ä¿®æ”¹é™éŸ³æŒ‰é’®æ ·å¼ï¼Œç¡®ä¿å›¾æ ‡åœ¨æŒ‰é’®å†…éƒ¨å®Œå…¨å±…ä¸­æ˜¾ç¤º
    muteBtn.style.fontSize = '24px'; // è°ƒæ•´å­—ä½“å¤§å°
    muteBtn.style.lineHeight = '50px'; // è®¾ç½®è¡Œé«˜ä¸æŒ‰é’®é«˜åº¦ä¸€è‡´ï¼Œä½¿å›¾æ ‡å‚ç›´å±…ä¸­
    muteBtn.style.textAlign = 'center'; // è®¾ç½®æ–‡æœ¬æ°´å¹³å±…ä¸­
    muteBtn.style.display = 'flex'; // ä½¿ç”¨ Flexbox å¸ƒå±€
    muteBtn.style.justifyContent = 'center'; // æ°´å¹³å±…ä¸­
    muteBtn.style.alignItems = 'center'; // å‚ç›´å±…ä¸­
    muteBtn.style.padding = '0'; // ç§»é™¤å†…è¾¹è·ï¼Œé¿å…å›¾æ ‡åç§»

    document.getElementById('gameContainer').appendChild(muteBtn);

    // åˆå§‹åŒ–é™éŸ³çŠ¶æ€
    let isMuted = localStorage.getItem('isMuted') === 'true'; // ä» localStorage è·å–é™éŸ³çŠ¶æ€
    if (isMuted) {
      bgMusic.pause();
      muteBtn.textContent = 'ğŸ”‡'; // æ˜¾ç¤ºé™éŸ³å›¾æ ‡
    } else {
      bgMusic.play();
      muteBtn.textContent = 'ğŸ”Š'; // æ˜¾ç¤ºéŸ³é‡å›¾æ ‡
    }

    // é™éŸ³æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    muteBtn.addEventListener('click', () => {
      isMuted = !isMuted;
      localStorage.setItem('isMuted', isMuted); // å°†é™éŸ³çŠ¶æ€ä¿å­˜åˆ° localStorage
      if (isMuted) {
        bgMusic.pause();
        muteBtn.textContent = 'ğŸ”‡'; // æ˜¾ç¤ºé™éŸ³å›¾æ ‡
      } else {
        bgMusic.play();
        muteBtn.textContent = 'ğŸ”Š'; // æ˜¾ç¤ºéŸ³é‡å›¾æ ‡
      }
    });
  </script>
</body>
</html>